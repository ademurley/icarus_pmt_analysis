////////////////////////////////////////////////////////////////////////////////
// Macro to analyze the PMT noise
// Process the noise analyis for the filename given as argument. Edit the input
// filename with the file you prefer. Note: the output will always be in the format
// "noise_run%d_00%d.root". you must change manually the variables run and subrun for now.
//
// Usage: root -l loadLib.cc noise_ana.cc
// Out of the box, it will produce a root file in the macro folder called "noise_run1264_1.root"
// with the ADC distribution of all the pmts in data_dl1_run1264_1_20200227T235326-decoded.root
// after baseline subtraction.
//
// mailto:ascarpell@bnl.gov
////////////////////////////////////////////////////////////////////////////////
#include "Run.h"
#include "Waveform.h"
#include "Pmt.h"

#include "TFile.h"
#include "TTree.h"
#include "TChain.h"
#include "TH1D.h"

using namespace std;

void charge_ana( string filename="run207_filenamelist.txt" )
{

  // CHANGE THE FILENAME BELOW IF WANT TO USE ONE OTHER FILE FOR YOUR ANALYSIS
  fstream fin(filename.c_str());
  string firstfilename = "";
  getline(fin, firstfilename);
  fin.close();
  RUN my_run(firstfilename);
  int run=my_run.getRun();
  int subrun=my_run.getSubrun();

  const int nboards=1;
  const int nchannels=16;

  //****************************************************************************
  // Input
  //

  TChain *tchain =  new TChain("caenv1730dump/events");

  // HERE you filename is loaded inside the macro to be processed!
  fstream fin1(filename.c_str());
  int nbOfFileCnt=0;
  while(fin1>>firstfilename){
    tchain->Add(firstfilename.c_str());
    nbOfFileCnt++;
  }
  fin1.close();
  cout<<"Processing run "<< run << ", with "<< nbOffFileCnt <<" files ..."<<endl;

  std::vector<std::vector<uint16_t> > *data=0; //unsigned short
  tchain->SetBranchAddress("fWvfmsVec", &data);


  //****************************************************************************
  // Now we create and initialize an histogram per each board and channel
  // This is an example, you can create more histograms using this model

  // baseline is really the basics for further processing the waveforms
  TH1D *h_pmt_rms[nboards][nchannels];
  TH1D *h_pmt_baseline[nboards][nchannels];

  // then we will want to look at waveforms characteristics:
  //     charge, amplitude, pulse time, number of pulse (for rate), etc.
  TH1D *h_pmt_charge[nboards][nchannels]; 
  TH1D* h_pmt_amplitude[nboards][nchannels];
  TH1D* h_pmt_pulsetime[nboards][nchannels];
  TH1D* h_pmt_NbOfPulses[nboards][nchannels];

  for(int board=0; board<nboards; board++)
  {
    for(int channel=0; channel<nchannels; channel++)
    {
      //DEFINE HERE THE HISTOGRAMS. EACH HISTOGRAM SHOULD HAVE A DIFFERENT NAME
      //TO AVOID CONFUSION WHEN YOU SAVE THEM TO FILE.
      char hname[100];
      sprintf(hname, "hnoise_run%d_00%d_board%d_channel%d_rms",
                                                   run, subrun, board, channel);
      h_pmt_rms[board][channel]= new TH1D(hname, hname, 40, -20, 20);

      sprintf(hname, "hnoise_run%d_00%d_board%d_channel%d_baseline",
                                                   run, subrun, board, channel);
      h_pmt_baseline[board][channel]= new TH1D(hname, hname, 40, 0, -1);
      h_pmt_baseline[board][channel]->SetBuffer(1);

      // for charge histograms
      sprintf(hname, "hQ_run%d_%d_board%d_ch%d", run, subrun, board, channel);
      h_pmt_charge[board][channel] = new TH1D(hname, hname, 200,0,100);
      h_pmt_charge[board][channel]->SetXTitle("Charge (pC)");
      h_pmt_charge[board][channel]->SetYTitle("Counts");
      // for amplitude histograms
      sprintf(hname, "hAmp_run%d_%d_board%d_ch%d", run, subrun, board, channel);
      h_pmt_amplitude[board][channel] = new TH1D(hname, hname, 500,0,5000);
      h_pmt_amplitude[board][channel]->SetXTitle("Amplitude (ADC count)");
      h_pmt_amplitude[board][channel]->SetYTitle("Counts");
      // for pulse time
      sprintf(hname, "hPulseTime_run%d_%d_board%d_ch%d", run, subrun, board, channel);
      h_pmt_pulsetime[board][channel] = new TH1D(hname, hname, 500,400,500);
      h_pmt_pulsetime[board][channel]->SetXTitle("Pulse start time (ns)");
      h_pmt_pulsetime[board][channel]->SetYTitle("Counts");
      // for number of pulse couting
      sprintf(hname, "hPulseCounting_run%d_%d_board%d_ch%d", run, subrun, board, channel);
      h_pmt_NbOfPulses[board][channel] = new TH1D(hname, hname, 15,0,15);
      h_pmt_NbOfPulses[board][channel]->SetXTitle("Number of pulses in the time set window");
      h_pmt_NbOfPulses[board][channel]->SetYTitle("Counts");
    }
  }

  //****************************************************************************
  // Now it is time to loop over the events
  //

  for(int e=0; e<tchain->GetEntries(); e++)
  {
    cout << "Processing event: " << e << endl;

    // WE TAKE THE EVENT
    tchain->GetEvent(e);

    for(int board=0; board<nboards; board++)
    {
      for(int channel=0; channel<nchannels; channel++)
      {

        // Create the WAVEFORM OBJECT
        Waveform *waveform = new Waveform(run, subrun ,e, board, channel);

        // ONCE THE DATA ARE LOADED IN THE WAVEFORM OBJECT, BASELINE IS
        // AUTOMATICALLY SUBSTRACTED. YOU CAN USE THE FUNCTION "getWaveform()"
        // TO EXTRACT THE WAVEFORM VECTOR AFTER BASELINE SUBTRACTION OR
        // "getRawWaveform()" BEFORE BASELINE SUBTRACTION.
        waveform->loadData((*data).at(channel+nchannels*board));

        if(!waveform->isValidWaveform()){ continue; }

        // Loop over the entries of the waveform after the baseline subtraction
        // and fill the entries of the histogram h_pmt_rms
        for( float entry : waveform->getWaveform() )
        {
          h_pmt_rms[board][channel]->Fill( entry );
        }

        h_pmt_baseline[board][channel]->Fill( waveform->getBaselineMean() );

      } // channel
    } // boards
  } // event



  //****************************************************************************
  // Output: create an output TFile and write the histogram in it
  //

  char ofilename[100]; sprintf(ofilename, "noise_run%d_charge_result.root", run);
  TFile ofile(ofilename, "RECREATE"); ofile.cd();

  TGraph *g_rms = new TGraph( nboards*nchannels );
  char gname[100]; sprintf(gname, "g_rms_run%d_", run);
  g_rms->SetTitle(gname); g_rms->SetName(gname);

  for(int board=0; board<nboards; board++)
  {
    for(int channel=0; channel<nchannels; channel++)
    {
      //Write the histogram to the output TFILE
      h_pmt_rms[board][channel]->Write();

      g_rms->SetPoint(channel+nchannels*board, channel+nchannels*board,
                                           h_pmt_rms[board][channel]->GetRMS());
      h_pmt_rms[board][channel]->Write();
      h_pmt_baseline[board][channel]->Write();
    }
  }

  ofile.Close();

  cout << "All done" << endl;

} //end macro
